<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.cyanzoy.top</id>
    <title>Sigma</title>
    <updated>2019-11-21T10:00:13.988Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.cyanzoy.top"/>
    <link rel="self" href="https://www.cyanzoy.top/atom.xml"/>
    <subtitle>为技术而生</subtitle>
    <logo>https://www.cyanzoy.top/images/avatar.png</logo>
    <icon>https://www.cyanzoy.top/favicon.ico</icon>
    <rights>All rights reserved 2019, Sigma</rights>
    <entry>
        <title type="html"><![CDATA[Python 异步编程asyncio模块]]></title>
        <id>https://www.cyanzoy.top/post/LfH2aK5oT</id>
        <link href="https://www.cyanzoy.top/post/LfH2aK5oT">
        </link>
        <updated>2019-11-21T07:44:10.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p><code>asyncio</code> 模块最大特点就是，只存在一个线程，跟 <code>JavaScript</code> 一样。<br>
由于只有一个线程，就不可能多个任务同时运行。<code>asyncio</code> 是&quot;多任务合作&quot;模式(cooperative multitasking)，允许异步任务交出执行权给其他任务，等到其他任务完成，再收回执行权继续往下执行，这跟 <code>JavaScript</code> 也是一样的。</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p><code>asyncio</code> 模块最大特点就是，只存在一个线程，跟 <code>JavaScript</code> 一样。<br>
由于只有一个线程，就不可能多个任务同时运行。<code>asyncio</code> 是&quot;多任务合作&quot;模式(cooperative multitasking)，允许异步任务交出执行权给其他任务，等到其他任务完成，再收回执行权继续往下执行，这跟 <code>JavaScript</code> 也是一样的。</p>
</blockquote>
<!-- more -->
<blockquote>
<p>由于代码的执行权在多个任务之间交换，所以看上去好像多个任务同时运行，其实底层只有一个线程，多个任务分享运行时间。</p>
</blockquote>
<blockquote>
<p>表面上，这是一个不合理的设计，明明有多线程多进程的能力，为什么放着多余的 <code>CPU</code> 核心不用，而只用一个线程呢？但是就像前面说的，单线程简化了很多问题，使得代码逻辑变得简单，写法符合直觉。<br>
<code>asyncio</code> 模块在单线程上启动一个事件循环(event loop)，时刻监听新进入循环的事件，加以处理，并不断重复这个过程，直到异步任务结束。事件循环的内部机制，可以参考 <code>JavaScript</code> 的模型，两者是一样的。</p>
</blockquote>
<pre><code class="language-python">#!/usr/bin/env python3
# async.py
# python3.7 及以上
import asyncio

async def count():
    print(&quot;One&quot;)
    await asyncio.sleep(1)
    print(&quot;Two&quot;)

async def main():
    await asyncio.gather(count(), count(), count())

asyncio.run(main())
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Savitzky-Golay 滤波器]]></title>
        <id>https://www.cyanzoy.top/post/ilNuF0noL</id>
        <link href="https://www.cyanzoy.top/post/ilNuF0noL">
        </link>
        <updated>2019-11-13T06:57:51.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[轨迹-异常值检测(三)]]></title>
        <id>https://www.cyanzoy.top/post/YiNcentC2</id>
        <link href="https://www.cyanzoy.top/post/YiNcentC2">
        </link>
        <updated>2019-11-11T04:59:14.000Z</updated>
        <summary type="html"><![CDATA[<p>LOF(Local Outlier Factor)</p>
]]></summary>
        <content type="html"><![CDATA[<p>LOF(Local Outlier Factor)</p>
<!-- more -->
<p>参考文章:<br>
1.<a href="https://blog.csdn.net/YE1215172385/article/details/79762317">离群点检测算法——LOF(Local Outlier Factor)</a><br>
2.<a href="https://blog.csdn.net/YE1215172385/article/details/79766906">异常检测(三)——Local Outlier Factor(LOF)</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[轨迹-异常值检测(二)]]></title>
        <id>https://www.cyanzoy.top/post/xnOx4dk3D</id>
        <link href="https://www.cyanzoy.top/post/xnOx4dk3D">
        </link>
        <updated>2019-11-11T04:58:56.000Z</updated>
        <summary type="html"><![CDATA[<p>IsolationForest</p>
]]></summary>
        <content type="html"><![CDATA[<p>IsolationForest</p>
<!-- more -->
<p>参考文章:<br>
1.<a href="https://blog.csdn.net/YE1215172385/article/details/79762317">异常检测（二）——IsolationForest</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[轨迹-异常值检测(一)]]></title>
        <id>https://www.cyanzoy.top/post/XUaCLWFv_</id>
        <link href="https://www.cyanzoy.top/post/XUaCLWFv_">
        </link>
        <updated>2019-11-11T04:58:26.000Z</updated>
        <summary type="html"><![CDATA[<p>OneClassSVM</p>
]]></summary>
        <content type="html"><![CDATA[<p>OneClassSVM</p>
<!-- more -->
<p>参考文章:<br>
1.<a href="https://blog.csdn.net/YE1215172385/article/details/79750703">异常检测（一）——OneClassSVM</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的re模块中match、search、findall、finditer的区别]]></title>
        <id>https://www.cyanzoy.top/post/qMULWET8f</id>
        <link href="https://www.cyanzoy.top/post/qMULWET8f">
        </link>
        <updated>2019-11-11T01:18:16.000Z</updated>
        <summary type="html"><![CDATA[<p>温习python中的re模块</p>
]]></summary>
        <content type="html"><![CDATA[<p>温习python中的re模块</p>
<!-- more -->
<h2 id="match">match</h2>
<p>匹配<code>string</code> <strong>开头</strong>,成功返回<code>Match object</code>, 失败返回None,只匹配一个。</p>
<h2 id="search">search</h2>
<p>在<code>string</code>中进行搜索,成功返回<code>Match object</code>, 失败返回None, 只匹配一个。</p>
<h2 id="findall">findall</h2>
<p>在<code>string</code>中查找所有匹配成功的组, 即用括号括起来的部分。返回list对象，每个<code>list item</code>是由每个匹配的所有组组成的list。</p>
<h2 id="finditer">finditer</h2>
<p>在<code>string</code>中查找所有匹配成功的字符串, 返回iterator,每个item是一个Match object。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IRR]]></title>
        <id>https://www.cyanzoy.top/post/PZwpK-fkr</id>
        <link href="https://www.cyanzoy.top/post/PZwpK-fkr">
        </link>
        <updated>2019-10-25T01:33:05.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux性能测试]]></title>
        <id>https://www.cyanzoy.top/post/YQMzxqNFJ</id>
        <link href="https://www.cyanzoy.top/post/YQMzxqNFJ">
        </link>
        <updated>2019-10-15T06:32:01.000Z</updated>
        <summary type="html"><![CDATA[<p>原文链接 https://blog.ilemonrain.com/linux/LemonBench.html</p>
]]></summary>
        <content type="html"><![CDATA[<p>原文链接 https://blog.ilemonrain.com/linux/LemonBench.html</p>
<!-- more -->
<h1 id="一-lemonbench-简单介绍">一、LemonBench 简单介绍</h1>
<p>LemonBench目前涵盖了如下测试：</p>
<p>服务器基础信息 (CPU信息/内存信息/Swap信息/磁盘空间信息等)<br>
Speedtest网速测试 (本地到最近源及国内各地域不同线路的网速)<br>
磁盘测试 (4K块/1M块 直接写入测试)<br>
路由追踪测试 (追踪到国内和海外不同线路的路由信息)<br>
Spoofer测试 (获取详细网络信息，快速判断服务器接入线路)<br>
LemonBench使用起来非常简单，只需要复制粘贴再来个回车就可以轻松启动测试。</p>
<h1 id="二-lemonbench-使用方法">二、LemonBench 使用方法</h1>
<h2 id="1-快速测试">1、快速测试</h2>
<p>如果你的服务器上安装有 <code>curl</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-sh">curl -fsSL https://ilemonrain.com/download/shell/LemonBench.sh | bash -s fast
</code></pre>
<p>如果你的服务器上安装有 <code>wget</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-sh">wget -qO- https://ilemonrain.com/download/shell/LemonBench.sh | bash -s fast
</code></pre>
<h2 id="2-完整测试">2、完整测试</h2>
<p>如果你的服务器上安装有 <code>curl</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-shell">curl -fsSL https://ilemonrain.com/download/shell/LemonBench.sh | bash -s full
</code></pre>
<p>如果你的服务器上安装有 <code>wget</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-shell">wget -qO- https://ilemonrain.com/download/shell/LemonBench.sh | bash -s full
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux-vim]]></title>
        <id>https://www.cyanzoy.top/post/XQroA40u4</id>
        <link href="https://www.cyanzoy.top/post/XQroA40u4">
        </link>
        <updated>2019-10-14T09:53:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vim中的搜索">vim中的搜索</h1>
<p>搜索方式： <code>/word</code><br>
下一个匹配 <code>n</code> 上一个匹配 <code>N</code><br>
第一个匹配处: <code>ggn</code><br>
最后一处 <code>GN</code></p>
<h2 id="自定义搜索">自定义搜索</h2>
<ol>
<li>通过设置 <code>hlsearch</code>来高亮搜索结果<pre><code class="language-shell">:set hlsearch
</code></pre>
</li>
<li>使搜索不区分大小写<pre><code class="language-shell"> :set ignorecase
</code></pre>
</li>
<li>智能大小写搜索<pre><code class="language-shell"> :set ignorecase
 :set smartcase
</code></pre>
</li>
<li>递进搜索<pre><code class="language-shell"> :set incsearch
</code></pre>
</li>
<li>禁止环形搜索<pre><code class="language-shell"> :set nowrapscan
</code></pre>
</li>
<li>再次开启环形搜索<pre><code class="language-shell"> :set wrapscan
</code></pre>
</li>
</ol>
<ul>
<li>如果你想要搜索一个文件中的一个单词，但是又不想输入它，你只需要将你的光标移到这个单词下然后按 <code>*</code>(或者 <code>shift + 8</code>)。如果你想要启动一次部分搜索(例如:同时搜索 <strong>in</strong> 和 <strong>terminal</strong>)，那你需要将光标移到到单词下，然后通过在键盘上按 <code>g*</code> (按一次 <code>g</code> 然后不断按 <code>*</code> )。<br>
<strong>另外</strong>:如果你想要逆向搜索，按 <code>#</code> 或者 <code>g#</code> 。</li>
<li>最后，假设你想要对文件中已经存在的单词做一点小小的修改，然后对修改后的单词执行搜索操作,一种方法是输入 <code>/</code> 与要搜索的单词。但是如果这个单词又长又复杂，那么可能需要一点时间来输入它。<br>
一个方法是将光标移到你想要略微修改的单词下，按 <code>/</code> 之后再按 <code>Ctrl + r</code> 最后按 <code>Ctrl + w</code>。这个在光标下的单词不仅仅会被拷贝，也会被复制到 <code>/</code> 后，允许你对它进行修改并且继续进行搜索操作。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uwsgi启动django服务+虚拟环境]]></title>
        <id>https://www.cyanzoy.top/post/_7T3uDhTS</id>
        <link href="https://www.cyanzoy.top/post/_7T3uDhTS">
        </link>
        <updated>2019-10-08T07:25:14.000Z</updated>
        <summary type="html"><![CDATA[<p>脚本列表<br>
启动django服务用的Uwsgi的ini启动配置文件,启动脚本,自定义service脚本</p>
]]></summary>
        <content type="html"><![CDATA[<p>脚本列表<br>
启动django服务用的Uwsgi的ini启动配置文件,启动脚本,自定义service脚本</p>
<!-- more -->
<h1 id="uwsgiini">uwsgi.ini</h1>
<pre><code class="language-ini"># uwsgi 配置文件
[uwsgi]
#端口
socket = 127.0.0.1:8000
# django项目绝对路径
chdir = /mnt/project/Blog/
# 模块路径（项目名称.wsgi）可以理解为wsgi.py的位置
module = Blog.wsgi
# 允许主进程
master = true
#最多进程数
processes  = 4
# 退出时候回收pid文件
vacuum = true
#日志大小配置500M
log-maxsize = 50000000
#记录日志配置
logto = /mnt/project/logs/Blog8000.log
pidfile = /mnt/project/logs/Blog8000.pid
daemonize = /mnt/project/logs/Blog/Blog.log
wsgi-file = /mnt/project/Blog/Blog/wsgi.py
virtualenv = /home/env/Blog_env
enable-threads = true
workers = 2
reload-mercy = 10
max-requests = 1000

#[uwsgi]
#socket = :8000
#master = true
#vhost = true
#gid = nginx
#uid = nginx
#no-stie = true
#enable-threads = true
#workers = 2
#reload-mercy = 10
#vacuum = true
#max-requests = 1000
#limit-as = 512
#buffer-sizi = 30000
#pidfile = /var/run/uwsgi8000diary.pid
#daemonize = /home/centos/project/logs/diary/uwsgi.log
#wsgi-file = /home/centos/project/diary/diary/wsgi.py
#chdir = /home/centos/project/diary
#module=diary.wsgi:application
#virtualenv = /usr/local/python3.7
#vacuum = True
</code></pre>
<h1 id="启动脚本-etcinitd">启动脚本 /etc/init.d/</h1>
<pre><code class="language-bash">#! /bin/sh
# chkconfig: 2345 55 25
# Description: Startup script for uwsgi webserver on Debian. Place in /etc/init.d and
# run 'update-rc.d -f uwsgi defaults', or use the appropriate command on your
# distro. For CentOS/Redhat run: 'chkconfig --add uwsgi'

### BEGIN INIT INFO
# Provides:          uwsgi
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts the uwsgi web server
# Description:       starts uwsgi using start-stop-daemon
### END INIT INFO

# Author:   licess
# website:  http://lnmp.org

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/python3.7/bin
DESC=&quot;uwsgi daemon&quot;
NAME=uwsgi8000diary
DAEMON=/usr/bin/uwsgi
CONFIGFILE=/home/centos/project/confini/$NAME.ini
PIDFILE=/var/run/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME

set -e
[ -x &quot;$DAEMON&quot; ] || exit 0

do_start() {
    $DAEMON --ini $CONFIGFILE || echo -n &quot;uwsgi already running&quot;
}

do_stop() {
    $DAEMON --stop $PIDFILE || echo -n &quot;uwsgi not running&quot;
    rm -f $PIDFILE
    echo &quot;$DAEMON STOPED.&quot;
}

do_reload() {
    $DAEMON --reload $PIDFILE || echo -n &quot;uwsgi can't reload&quot;
}

do_status() {
    ps aux|grep $DAEMON
}

case &quot;$1&quot; in
 status)
    echo -en &quot;Status $NAME: \n&quot;
    do_status
 ;;
 start)
    echo -en &quot;Starting $NAME: \n&quot;
    do_start
 ;;
 stop)
    echo -en &quot;Stopping $NAME: \n&quot;
    do_stop
 ;;
 reload|graceful)
    echo -en &quot;Reloading $NAME: \n&quot;
    do_reload
 ;;
 *)
    echo &quot;Usage: $SCRIPTNAME {start|stop|reload}&quot; &gt;&amp;2
    exit 3
 ;;
esac

exit 0

</code></pre>
<h1 id="service-脚本-usrlibsystemdsystem">service 脚本 /usr/lib/systemd/system/</h1>
<pre><code class="language-ini">[Unit]
Documentation=man:systemd-sysv-generator(8)
SourcePath=/etc/rc.d/init.d/uwsgi9500_meetbuy
Description=LSB: starts the uwsgi web server
Before=runlevel2.target
Before=runlevel3.target
Before=runlevel4.target
Before=runlevel5.target
Before=shutdown.target
Before=agentwatch.service
After=all.target
After=network-online.target
Conflicts=shutdown.target

[Service]
Type=forking
Restart=no
TimeoutSec=5min
IgnoreSIGPIPE=no
KillMode=process
GuessMainPID=no
RemainAfterExit=yes
ExecStart=/etc/init.d/uwsgi9500_meetbuy start
ExecStop=/etc/init.d/uwsgi9500_meetbuy stop
ExecReload=/etc/init.d/uwsgi9500_meetbuy reload
</code></pre>
<h1 id="nginx中的配置">Nginx中的配置</h1>
<pre><code class="language-nginx">    server {
        listen       80;
        server_name  bus.cyanzoy.top;

        location / {
           include /usr/local/nginx/conf/uwsgi_params;
           uwsgi_pass 127.0.0.1:8000;

        }
        location /static {
            alias   /mnt/project/Blog/static/;
        }
    }
</code></pre>
<h1 id="最终脚本">最终脚本</h1>
<pre><code class="language-sh">#! /bin/sh

# 打开项目地址
cd /mnt/project/Blog
# 清空启动日志
echo &quot;&quot; &gt; /mnt/project/logs/Blog/Blog.log
# 更新项目
git pull origin master
# 重启uwsgi
systemctl stop Blog
systemctl start Blog
# 打开日志
tail -fn 20 /mnt/project/logs/Blog/Blog.log

</code></pre>
]]></content>
    </entry>
</feed>