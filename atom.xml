<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.cyanzoy.top</id>
    <title>MAOA-L</title>
    <updated>2019-10-24T06:35:18.255Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.cyanzoy.top"/>
    <link rel="self" href="https://www.cyanzoy.top/atom.xml"/>
    <subtitle>为技术而生</subtitle>
    <logo>https://www.cyanzoy.top/images/avatar.png</logo>
    <icon>https://www.cyanzoy.top/favicon.ico</icon>
    <rights>All rights reserved 2019, MAOA-L</rights>
    <entry>
        <title type="html"><![CDATA[备忘录]]></title>
        <id>https://www.cyanzoy.top/post/fnyLymsmv</id>
        <link href="https://www.cyanzoy.top/post/fnyLymsmv">
        </link>
        <updated>2019-10-24T06:29:53.000Z</updated>
        <summary type="html"><![CDATA[<p>预防老年痴呆,人人有责</p>
]]></summary>
        <content type="html"><![CDATA[<p>预防老年痴呆,人人有责</p>
<!-- more -->
<h1 id="关于服务器项目的一些备忘">关于服务器项目的一些备忘</h1>
<p>项目虚拟环境统一放在 /home/env/ 下<br>
自定义service放在 /usr/lib/systemd/system/ 目录下<br>
运行脚本放在/etc/init.d/ 目录下</p>
<h1 id="关于项目环境的一些备忘">关于项目环境的一些备忘</h1>
<p>source 进入python的虚拟环境后，直接运行deactivate退出虚拟环境<br>
linux安装mysqlclient需要环境mysql-devel</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux性能测试]]></title>
        <id>https://www.cyanzoy.top/post/YQMzxqNFJ</id>
        <link href="https://www.cyanzoy.top/post/YQMzxqNFJ">
        </link>
        <updated>2019-10-15T06:32:01.000Z</updated>
        <summary type="html"><![CDATA[<p>原文链接 https://blog.ilemonrain.com/linux/LemonBench.html</p>
]]></summary>
        <content type="html"><![CDATA[<p>原文链接 https://blog.ilemonrain.com/linux/LemonBench.html</p>
<!-- more -->
<h1 id="一-lemonbench-简单介绍">一、LemonBench 简单介绍</h1>
<p>LemonBench目前涵盖了如下测试：</p>
<p>服务器基础信息 (CPU信息/内存信息/Swap信息/磁盘空间信息等)<br>
Speedtest网速测试 (本地到最近源及国内各地域不同线路的网速)<br>
磁盘测试 (4K块/1M块 直接写入测试)<br>
路由追踪测试 (追踪到国内和海外不同线路的路由信息)<br>
Spoofer测试 (获取详细网络信息，快速判断服务器接入线路)<br>
LemonBench使用起来非常简单，只需要复制粘贴再来个回车就可以轻松启动测试。</p>
<h1 id="二-lemonbench-使用方法">二、LemonBench 使用方法</h1>
<h2 id="1-快速测试">1、快速测试</h2>
<p>如果你的服务器上安装有 <code>curl</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-sh">curl -fsSL https://ilemonrain.com/download/shell/LemonBench.sh | bash -s fast
</code></pre>
<p>如果你的服务器上安装有 <code>wget</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-sh">wget -qO- https://ilemonrain.com/download/shell/LemonBench.sh | bash -s fast
</code></pre>
<h2 id="2-完整测试">2、完整测试</h2>
<p>如果你的服务器上安装有 <code>curl</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-shell">curl -fsSL https://ilemonrain.com/download/shell/LemonBench.sh | bash -s full
</code></pre>
<p>如果你的服务器上安装有 <code>wget</code> 工具，请使用以下命令执行脚本：</p>
<pre><code class="language-shell">wget -qO- https://ilemonrain.com/download/shell/LemonBench.sh | bash -s full
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux-vim]]></title>
        <id>https://www.cyanzoy.top/post/XQroA40u4</id>
        <link href="https://www.cyanzoy.top/post/XQroA40u4">
        </link>
        <updated>2019-10-14T09:53:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vim中的搜索">vim中的搜索</h1>
<p>搜索方式： <code>/word</code><br>
下一个匹配 <code>n</code> 上一个匹配 <code>N</code><br>
第一个匹配处: <code>ggn</code><br>
最后一处 <code>GN</code></p>
<h2 id="自定义搜索">自定义搜索</h2>
<ol>
<li>通过设置 <code>hlsearch</code>来高亮搜索结果<pre><code class="language-shell">:set hlsearch
</code></pre>
</li>
<li>使搜索不区分大小写<pre><code class="language-shell"> :set ignorecase
</code></pre>
</li>
<li>智能大小写搜索<pre><code class="language-shell"> :set ignorecase
 :set smartcase
</code></pre>
</li>
<li>递进搜索<pre><code class="language-shell"> :set incsearch
</code></pre>
</li>
<li>禁止环形搜索<pre><code class="language-shell"> :set nowrapscan
</code></pre>
</li>
<li>再次开启环形搜索<pre><code class="language-shell"> :set wrapscan
</code></pre>
</li>
</ol>
<ul>
<li>如果你想要搜索一个文件中的一个单词，但是又不想输入它，你只需要将你的光标移到这个单词下然后按 <code>*</code>(或者 <code>shift + 8</code>)。如果你想要启动一次部分搜索(例如:同时搜索 <strong>in</strong> 和 <strong>terminal</strong>)，那你需要将光标移到到单词下，然后通过在键盘上按 <code>g*</code> (按一次 <code>g</code> 然后不断按 <code>*</code> )。<br>
<strong>另外</strong>:如果你想要逆向搜索，按 <code>#</code> 或者 <code>g#</code> 。</li>
<li>最后，假设你想要对文件中已经存在的单词做一点小小的修改，然后对修改后的单词执行搜索操作,一种方法是输入 <code>/</code> 与要搜索的单词。但是如果这个单词又长又复杂，那么可能需要一点时间来输入它。<br>
一个方法是将光标移到你想要略微修改的单词下，按 <code>/</code> 之后再按 <code>Ctrl + r</code> 最后按 <code>Ctrl + w</code>。这个在光标下的单词不仅仅会被拷贝，也会被复制到 <code>/</code> 后，允许你对它进行修改并且继续进行搜索操作。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[uwsgi启动django服务]]></title>
        <id>https://www.cyanzoy.top/post/_7T3uDhTS</id>
        <link href="https://www.cyanzoy.top/post/_7T3uDhTS">
        </link>
        <updated>2019-10-08T07:25:14.000Z</updated>
        <summary type="html"><![CDATA[<p>脚本列表<br>
启动django服务用的Uwsgi的ini启动配置文件,启动脚本,自定义service脚本</p>
]]></summary>
        <content type="html"><![CDATA[<p>脚本列表<br>
启动django服务用的Uwsgi的ini启动配置文件,启动脚本,自定义service脚本</p>
<!-- more -->
<h1 id="uwsgiini">uwsgi.ini</h1>
<pre><code class="language-ini"># uwsgi 配置文件
[uwsgi]
#端口
socket = 127.0.0.1:8000
# django项目绝对路径
chdir = /home/centos/project/diary
# 模块路径（项目名称.wsgi）可以理解为wsgi.py的位置
module = diary.wsgi
# 允许主进程
master = true
#最多进程数
processes  = 4
# 退出时候回收pid文件
vacuum = true
#日志大小配置500M
log-maxsize = 500000000 
#记录日志配置
logto = /home/centos/project/logs/uwsgi8000.log
pidfile = /home/centos/project/logs/uwsgi8000.pid

#[uwsgi]
#socket = :8000
#master = true
#vhost = true
#gid = nginx
#uid = nginx
#no-stie = true
#enable-threads = true
#workers = 2
#reload-mercy = 10
#vacuum = true
#max-requests = 1000
#limit-as = 512
#buffer-sizi = 30000
#pidfile = /var/run/uwsgi8000diary.pid
#daemonize = /home/centos/project/logs/diary/uwsgi.log
#wsgi-file = /home/centos/project/diary/diary/wsgi.py
#chdir = /home/centos/project/diary
#module=diary.wsgi:application
#virtualenv = /usr/local/python3.7
#vacuum = True
</code></pre>
<h1 id="启动脚本-etcinitd">启动脚本 /etc/init.d/</h1>
<pre><code class="language-bash">#! /bin/sh
# chkconfig: 2345 55 25
# Description: Startup script for uwsgi webserver on Debian. Place in /etc/init.d and
# run 'update-rc.d -f uwsgi defaults', or use the appropriate command on your
# distro. For CentOS/Redhat run: 'chkconfig --add uwsgi'

### BEGIN INIT INFO
# Provides:          uwsgi
# Required-Start:    $all
# Required-Stop:     $all
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts the uwsgi web server
# Description:       starts uwsgi using start-stop-daemon
### END INIT INFO

# Author:   licess
# website:  http://lnmp.org

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/python3.7/bin
DESC=&quot;uwsgi daemon&quot;
NAME=uwsgi8000diary
DAEMON=/usr/bin/uwsgi
CONFIGFILE=/home/centos/project/confini/$NAME.ini
PIDFILE=/var/run/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME

set -e
[ -x &quot;$DAEMON&quot; ] || exit 0

do_start() {
    $DAEMON --ini $CONFIGFILE || echo -n &quot;uwsgi already running&quot;
}

do_stop() {
    $DAEMON --stop $PIDFILE || echo -n &quot;uwsgi not running&quot;
    rm -f $PIDFILE
    echo &quot;$DAEMON STOPED.&quot;
}

do_reload() {
    $DAEMON --reload $PIDFILE || echo -n &quot;uwsgi can't reload&quot;
}

do_status() {
    ps aux|grep $DAEMON
}

case &quot;$1&quot; in
 status)
    echo -en &quot;Status $NAME: \n&quot;
    do_status
 ;;
 start)
    echo -en &quot;Starting $NAME: \n&quot;
    do_start
 ;;
 stop)
    echo -en &quot;Stopping $NAME: \n&quot;
    do_stop
 ;;
 reload|graceful)
    echo -en &quot;Reloading $NAME: \n&quot;
    do_reload
 ;;
 *)
    echo &quot;Usage: $SCRIPTNAME {start|stop|reload}&quot; &gt;&amp;2
    exit 3
 ;;
esac

exit 0

</code></pre>
<h1 id="service-脚本-usrlibsystemdsystem">service 脚本 /usr/lib/systemd/system/</h1>
<pre><code class="language-ini">[Unit]
Documentation=man:systemd-sysv-generator(8)
SourcePath=/etc/rc.d/init.d/uwsgi9500_meetbuy
Description=LSB: starts the uwsgi web server
Before=runlevel2.target
Before=runlevel3.target
Before=runlevel4.target
Before=runlevel5.target
Before=shutdown.target
Before=agentwatch.service
After=all.target
After=network-online.target
Conflicts=shutdown.target

[Service]
Type=forking
Restart=no
TimeoutSec=5min
IgnoreSIGPIPE=no
KillMode=process
GuessMainPID=no
RemainAfterExit=yes
ExecStart=/etc/rc.d/init.d/uwsgi9500_meetbuy start
ExecStop=/etc/rc.d/init.d/uwsgi9500_meetbuy stop
ExecReload=/etc/rc.d/init.d/uwsgi9500_meetbuy reloa
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx安装]]></title>
        <id>https://www.cyanzoy.top/post/NzkqO5w9Y</id>
        <link href="https://www.cyanzoy.top/post/NzkqO5w9Y">
        </link>
        <updated>2019-09-27T09:02:15.000Z</updated>
        <summary type="html"><![CDATA[<p>简介记录nginx的安装</p>
]]></summary>
        <content type="html"><![CDATA[<p>简介记录nginx的安装</p>
<!-- more -->
<h1 id="需要的依赖环境">需要的依赖环境</h1>
<pre><code>yum -y install pcre pcre-devel
yum install openssl openssl-devel
</code></pre>
<h1 id="编译-安装">编译 &amp;&amp; 安装</h1>
<pre><code>./configure --prefix=/usr/local/nginx --with-http_ssl_module
make &amp;&amp; make install
</code></pre>
<h1 id="启动">启动</h1>
<pre><code class="language-sh">nginx
</code></pre>
<h1 id="重启">重启</h1>
<pre><code class="language-sh">nginx -s reload
</code></pre>
<h1 id="指定配置文件的启动">指定配置文件的启动</h1>
<pre><code class="language-sh">nginx -c /usr/local/nginx/conf/nginx.conf
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库]]></title>
        <id>https://www.cyanzoy.top/post/LfyAN6ymf</id>
        <link href="https://www.cyanzoy.top/post/LfyAN6ymf">
        </link>
        <updated>2019-09-23T07:59:06.000Z</updated>
        <summary type="html"><![CDATA[<p>一系列命令</p>
]]></summary>
        <content type="html"><![CDATA[<p>一系列命令</p>
<!-- more -->
<h1 id="创建用户授权设更改加密模式">创建用户，授权，设更改加密模式</h1>
<h2 id="创建账号">创建账号</h2>
<pre><code>CREATE USER 'username'@'host' IDENTIFIED BY 'password';
</code></pre>
<h2 id="授权">授权</h2>
<pre><code>GRANT privileges ON databasename.tablename TO 'username'@'host'
GRANT ALL ON databasename.* TO 'username'@'host'
说明:
# privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL 
# databasename：数据库名
# tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.*
</code></pre>
<pre><code>注意:
用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:
GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;
</code></pre>
<h2 id="设置与更改用户密码">设置与更改用户密码</h2>
<pre><code>命令:
SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');
如果是当前登陆用户用:
SET PASSWORD = PASSWORD(&quot;newpassword&quot;);
例子:
SET PASSWORD FOR 'pig'@'%' = PASSWORD(&quot;123456&quot;);
</code></pre>
<h2 id="撤销用户权限">撤销用户权限</h2>
<pre><code>REVOKE privilege ON databasename.tablename FROM 'username'@'host';
说明:
privilege, databasename, tablename：同授权部分
例子:
REVOKE SELECT ON *.* FROM 'pig'@'%';
假如你在给用户 'pig'@ '%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON . FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT 操作。
同理，如果授权使用的是GRANT SELECT ON . TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对test数据库中user表的Select权限。
具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看。
</code></pre>
<h2 id="删除用户">删除用户</h2>
<pre><code>DROP USER 'username'@'host';
</code></pre>
<h2 id="mysql8-加密方式不同如有需要可运行下面这句进行更改">mysql8 加密方式不同，如有需要可运行下面这句进行更改</h2>
<pre><code>ALTER USER 'tone'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
FLUSH PRIVILEGES; 
</code></pre>
<h1 id="数据路加解密sql">数据路加解密sql</h1>
<pre><code class="language-sql">fjarg3z30xtjcewyonjkkh6g7qub4tdei0dhu4bog 密钥
解密
SELECT AES_DECRYPT(UNHEX('已加密内容'), 'fjarg3z30xtjcewyonjkkh6g7qub4tdei0dhu4bog')
加密
SELECT  HEX(AES_ENCRYPT('待加密内容', 'fjarg3z30xtjcewyonjkkh6g7qub4tdei0dhu4bog'))
</code></pre>
<h2 id="其他">其他</h2>
<p>1.数据库目录<br>
/var/lib/mysql/<br>
2.配置文件<br>
/usr/share/mysql（mysql.server命令及配置文件）mysql5.5之后的默认安装路径，mysql5.5之前的是/usr/local/mysql<br>
3.相关命令<br>
/usr/bin(mysqladmin mysqldump等命令)<br>
4.启动脚本<br>
/etc/rc.d/init.d/（启动脚本文件mysql的目录）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后端必备 Nginx 配置]]></title>
        <id>https://www.cyanzoy.top/post/9XwZQILat</id>
        <link href="https://www.cyanzoy.top/post/9XwZQILat">
        </link>
        <updated>2019-09-19T02:55:54.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>防盗链</li>
<li>根据文件类型设置过期时间</li>
<li>静态资源访问<br>
···</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>防盗链</li>
<li>根据文件类型设置过期时间</li>
<li>静态资源访问<br>
···</li>
</ul>
<!-- more -->
<ul>
<li>日志配置</li>
<li>日志字段说明</li>
<li>access_log 访问日志</li>
<li>error_log 日志</li>
<li>日志切割</li>
<li>反向代理</li>
<li>禁止指定user_agent</li>
<li>nginx访问控制</li>
<li>负载均衡</li>
<li>Nginx的rewrite</li>
</ul>
<h2 id="防盗链">防盗链</h2>
<pre><code>location ~* \.(gif|jpg|png)$ {
    # 只允许 192.168.0.1 请求资源
    valid_referers none blocked 192.168.0.1;
    if ($invalid_referer) {
       rewrite ^/ http://$host/logo.png;
    }
}
</code></pre>
<h2 id="根据文件类型设置过期时间">根据文件类型设置过期时间</h2>
<pre><code>location ~.*\.css$ {
    expires 1d;
    break;
}
location ~.*\.js$ {
    expires 1d;
    break;
}
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {
    access_log off;
    expires 15d;    #保存15天
    break;
}

# curl -x127.0.0.1:80 http://www.test.com/static/image/common/logo.png -I #
测试图片的max-age
</code></pre>
<h2 id="静态资源访问">静态资源访问</h2>
<pre><code>http {
    # 这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，
    # 建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。
    open_file_cache max=204800 inactive=20s;

    # open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，
    # 如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个
    # 文件在inactive 时间内一次没被使用，它将被移除。
    open_file_cache_min_uses 1;

    # 这个是指多长时间检查一次缓存的有效信息
    open_file_cache_valid 30s;

    # 默认情况下，Nginx的gzip压缩是关闭的， gzip压缩功能就是可以让你节省不
    # 少带宽，但是会增加服务器CPU的开销哦，Nginx默认只对text/html进行压缩 ，
    # 如果要对html之外的内容进行压缩传输，我们需要手动来设置。
    gzip on;
    gzip_min_length 1k;
    gzip_buffers 4 16k;
    gzip_http_version 1.0;
    gzip_comp_level 2;
    gzip_types text/plain application/x-javascript text/css application/xml;


    server {
        listen       80;
        server_name www.test.com;
        charset utf-8;
        root   /data/www.test.com;
        index  index.html index.htm;
    }
}
</code></pre>
<h2 id="日志配置">日志配置</h2>
<h3 id="日志字段说明">日志字段说明</h3>
<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>remote_addr 和 http_x_forwarded_for</td>
<td>客户端 IP 地址</td>
</tr>
<tr>
<td>remote_user</td>
<td>客户端用户名称</td>
</tr>
<tr>
<td>request</td>
<td>请求的 URI 和 HTTP 协议</td>
</tr>
<tr>
<td>status</td>
<td>请求状态</td>
</tr>
<tr>
<td>body_bytes_sent</td>
<td>返回给客户端的字节数，不包括响应头的大小</td>
</tr>
<tr>
<td>bytes_sent</td>
<td>返回给客户端总字节数</td>
</tr>
<tr>
<td>connection</td>
<td>连接的序列号</td>
</tr>
<tr>
<td>connection_requests</td>
<td>当前同一个 TCP 连接的的请求数量</td>
</tr>
<tr>
<td>msec</td>
<td>日志写入时间。单位为秒，精度是毫秒</td>
</tr>
<tr>
<td>pipe</td>
<td>如果请求是通过HTTP流水线(pipelined)发送，pipe值为&quot;p&quot;，否则为&quot;.&quot;</td>
</tr>
<tr>
<td>http_referer</td>
<td>记录从哪个页面链接访问过来的</td>
</tr>
<tr>
<td>http_user_agent</td>
<td>记录客户端浏览器相关信息</td>
</tr>
<tr>
<td>request_length</td>
<td>请求的长度(包括请求行，请求头和请求正文)</td>
</tr>
<tr>
<td>time_iso8601</td>
<td>ISO8601标准格式下的本地时间</td>
</tr>
<tr>
<td>time_local</td>
<td>记录访问时间与时区</td>
</tr>
</tbody>
</table>
<h2 id="access_log-访问日志">access_log 访问日志</h2>
<pre><code>http {
    log_format  access  '$remote_addr - $remote_user [$time_local] $host &quot;$request&quot; '
                  '$status $body_bytes_sent &quot;$http_referer&quot; '
                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$clientip&quot;';
    access_log  /srv/log/nginx/talk-fun.access.log  access;
}
</code></pre>
<h2 id="error_log-日志">error_log 日志</h2>
<pre><code>error_log  /srv/log/nginx/nginx_error.log  error;
# error_log /dev/null; # 真正的关闭错误日志
http {
    # ...
}
</code></pre>
<h2 id="日志切割">日志切割</h2>
<pre><code># 和apache不同的是，nginx没有apache一样的工具做切割，需要编写脚本实现。# 在/usr/local/sbin下写脚本

#!/bin/bash
dd=$(date -d '-1 day' +%F)[ -d /tmp/nginx_log ] || mkdir /tmp/nginx_log
mv /tmp/nginx_access.log /tmp/nginx_log/$dd.log
/etc/init.d/nginx reload &gt; /dev/null
</code></pre>
<h2 id="反向代理">反向代理</h2>
<pre><code>http {
    include mime.types;
    server_tokens off;

    ## 配置反向代理的参数
    server {
        listen    8080;

        ## 1. 用户访问 http://ip:port，则反向代理到 https://github.com
        location / {
            proxy_pass  https://github.com;
            proxy_redirect     off;
            proxy_set_header   Host             $host;
            proxy_set_header   X-Real-IP        $remote_addr;
            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        }

        ## 2.用户访问 http://ip:port/README.md，则反向代理到
        ##   https://github.com/zibinli/blog/blob/master/README.md
        location /README.md {
            proxy_set_header  X-Real-IP  $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass https://github.com/zibinli/blog/blob/master/README.md;
        }
    }
}
</code></pre>
<h2 id="禁止指定user_agent">禁止指定user_agent</h2>
<pre><code>#虚拟主机的配置文件里加入：
if ($http_user_agent ~* 'baidu|360|sohu') #禁止useragent为baidu、360和sohu，~*表示不区分大小写匹配
{
   return 403;
}

location /  和  location  ~ /  优先级是不一样的。 
结合这个文章研究一下吧 http://blog.itpub.net/27181165/viewspace-777202/
curl -A &quot;baidu&quot; -x127.0.0.1:80 www.test.com/forum.php -I    该命令指定百度为user_agent,返回403
</code></pre>
<h2 id="nginx访问控制">nginx访问控制</h2>
<pre><code># 可以设置一些配置禁止一些ip的访问

deny 127.0.0.1;     #全局定义限制，location里的是局部定义的。如果两者冲突，以location这种精确地优先，

location ~ .*admin\.php$ {
    #auth_basic &quot;cct auth&quot;;
    #auth_basic_user_file /usr/local/nginx/conf/.htpasswd;

    allow 127.0.0.1;  只允许127.0.0.1的访问，其他均拒绝
    deny all;

    include fastcgi_params;
    fastcgi_pass unix:/tmp/www.sock;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /data/www$fastcgi_script_name;
}
</code></pre>
<h2 id="负载均衡">负载均衡</h2>
<pre><code>http {
    upstream test.net {
        ip_hash;
        server 192.168.10.13:80;
        server 192.168.10.14:80  down;
        server 192.168.10.15:8009  max_fails=3  fail_timeout=20s;
        server 192.168.10.16:8080;
    }
    server {
        location / {
            proxy_pass  http://test.net;
        }
    }
}
</code></pre>
<h1 id="nginx的rewrite">Nginx的rewrite</h1>
<h2 id="rewite">rewite</h2>
<p>在<code>server</code>块下，会优先执行<code>rewrite</code>部分，然后才会去匹配<code>location</code>块<br>
<code>server</code>中的<code>rewrite break</code>和<code>last</code>没什么区别，都会去匹配<code>location</code>，所以没必要用<code>last</code>再发起新的请求，可以留空</p>
<h2 id="location中的rewirte">location中的rewirte：</h2>
<p>不写last和break - 那么流程就是依次执行这些rewrite</p>
<ol>
<li><code>rewrite break</code> - url重写后，直接使用当前资源，不再执行location里余下的语句，完成本次请求，地址栏url不变</li>
<li><code>rewrite last</code> - url重写后，马上发起一个新的请求，再次进入server块，重试location匹配，超过10次匹配不到报500错误，地址栏url不变</li>
<li><code>rewrite redirect</code> – 返回302临时重定向，地址栏显示重定向后的url，爬虫不会更新url（因为是临时）</li>
<li><code>rewrite permanent</code> – 返回301永久重定向, 地址栏显示重定向后的url，爬虫更新url</li>
</ol>
<h2 id="使用last会对server标签重新发起请求">使用last会对server标签重新发起请求</h2>
<ul>
<li>如果location中rewrite后是对静态资源的请求，不需要再进行其他匹配，一般要使用break或不写，直接使用当前location中的数据源，完成本次请求</li>
<li>如果location中rewrite后，还需要进行其他处理，如动态fastcgi请求(.php,.jsp)等，要用last继续发起新的请求</li>
<li>(根的location使用last比较好, 因为如果有.php等fastcgi请求还要继续处理)</li>
<li>使用alias指定源：必须使用last</li>
<li>if语句主要用来判断一些在rewrite语句中无法直接匹配的条件,比如检测文件存在与否,http header,cookie等</li>
</ul>
<h2 id="location匹配规则及优先级">location匹配规则及优先级</h2>
<table>
<thead>
<tr>
<th>匹配规则</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>严格匹配这个查询。如果找到，停止搜索。</td>
</tr>
<tr>
<td>^~</td>
<td>匹配路径的前缀，如果找到，停止搜索。</td>
</tr>
<tr>
<td>~</td>
<td>为区分大小写的正则匹配</td>
</tr>
<tr>
<td>~*</td>
<td>为不区分大小写匹配</td>
</tr>
<tr>
<td>优先级：</td>
<td>=, ^~, <sub>/</sub>*, 无</td>
</tr>
</tbody>
</table>
<h2 id="break语句">break语句</h2>
<p>放在<code>server</code>块<code>rewrite</code>语句前面<br>
如果是直接请求某个真实存在的文件,则用break语句停止rewrite检查</p>
<pre><code>if (-f $request_filename) { 
    break; 
}
</code></pre>
<h1 id="记录">记录</h1>
<pre><code class="language-nginx">http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
    #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
    #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    server {
        listen       80;
        server_name  www.cyanzoy.top;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   /mnt/project/blog/MAOA-L.github.io/;
	        rewrite ^/(.*) https://www.cyanzoy.top/$1 last;
            # index  index.html index.htm;
        }        
	    location /styles {
            alias   /mnt/project/blog/MAOA-L.github.io/styles/;
        }
        # 如果是做代理(django-uwsgi服务)
        location / {
            #root   /usr/share/nginx/aichensmart;
            #index  index.php index.html index.htm;
            include /etc/nginx/uwsgi_params;
            uwsgi_pass 127.0.0.1:port;
        }

	
        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

    server {
        listen 	    443 ssl;
        server_name www.cyanzoy.top;
        # ssl on;
        # root /mnt/project/blog/MAOA-L.github.io/;
        # index index.html index.htm;
        ssl_certificate   /usr/local/nginx/cert/2880038_www.cyanzoy.top.pem;
        ssl_certificate_key  /usr/local/nginx/cert/2880038_www.cyanzoy.top.key;
        ssl_session_timeout 5m;
        # ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        # ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers on;
        location / {
            root /mnt/project/blog/MAOA-L.github.io/;
            index index.html index.htm;
        }
    }

}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[扣减库存]]></title>
        <id>https://www.cyanzoy.top/post/UL3LlJVMC</id>
        <link href="https://www.cyanzoy.top/post/UL3LlJVMC">
        </link>
        <updated>2019-09-18T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>使用CAS, <code>update table set v_1 = aa where id = xx and v_1 = old_v_1</code></p>
<blockquote>
<p>CAS ☞ compare/check and swap/set</p>
</blockquote>
<p>上面的方案,可能会出现一个CAS中经典问题. ABA的问题.</p>
<pre><code>ABA是指:
线程T1 查询,库存剩余  100
线程T2 查询,库存剩余  100
线程T1 执行subupdate t set surplus = 90 where id = x and surplus = 100;
线程T3 查询, 库存剩余 90
线程T3 执行add  update t set surplus = 100 where id = x and surplus = 90;
线程T2 执行subupdate t set surplus = 90 where id = x and surplus = 100;
</code></pre>
<p>这里线程T2执行的时候,库存的100已经不是查询到的100了<br>
一般的设计中CAS会使用version来控制.</p>
<pre><code>update t set surplus = 90 ,version = version+1 where id = x and version = oldVersion;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 笔记]]></title>
        <id>https://www.cyanzoy.top/post/git-bi-ji</id>
        <link href="https://www.cyanzoy.top/post/git-bi-ji">
        </link>
        <updated>2019-09-17T14:29:28.000Z</updated>
        <summary type="html"><![CDATA[<p>git的一些命令记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>git的一些命令记录</p>
<!-- more -->
<p>🔹Git 添加远程仓库关联</p>
<pre><code>git remote add origin git@github.com:MAOA-L/AliPayApplet.git
git push -u origin master 
#这句一般与上句一起用。用于远程仓库没有初始化时
</code></pre>
<p>🔸Git 本地分支关联远程分支</p>
<pre><code>git branch --set-upstream-to=origin/remote_branch  your_branch
</code></pre>
<p>🔹Git 删除本地分支</p>
<pre><code>git branch -d [branchname]
</code></pre>
<p>🔸Git 删除远程分支</p>
<pre><code>git push origin --delete [branchname]
</code></pre>
<blockquote>
<p><code>Q&amp;A</code><br>
🧐: git branch 不显示分支原因<br>
🤪: git branch要在git commit后才会显示分支.<br>
🧐:nginx的location、root、alias指令用法和区别<br>
🤪:</p>
</blockquote>
]]></content>
    </entry>
</feed>