<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.cyanzoy.top</id>
    <title>MAOA-L</title>
    <updated>2019-09-29T07:00:34.204Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.cyanzoy.top"/>
    <link rel="self" href="https://blog.cyanzoy.top/atom.xml"/>
    <subtitle>为技术而生</subtitle>
    <logo>https://blog.cyanzoy.top/images/avatar.png</logo>
    <icon>https://blog.cyanzoy.top/favicon.ico</icon>
    <rights>All rights reserved 2019, MAOA-L</rights>
    <entry>
        <title type="html"><![CDATA[Nginx安装]]></title>
        <id>https://blog.cyanzoy.top/post/NzkqO5w9Y</id>
        <link href="https://blog.cyanzoy.top/post/NzkqO5w9Y">
        </link>
        <updated>2019-09-27T09:02:15.000Z</updated>
        <summary type="html"><![CDATA[<p>简介记录nginx的安装</p>
]]></summary>
        <content type="html"><![CDATA[<p>简介记录nginx的安装</p>
<!-- more -->
<h1 id="需要的依赖环境">需要的依赖环境</h1>
<pre><code>yum -y install pcre pcre-devel
yum install openssl openssl-devel
</code></pre>
<h1 id="编译-安装">编译 &amp;&amp; 安装</h1>
<pre><code>./configure --prefix=/usr/local/nginx --with-http_ssl_module
make &amp;&amp; make install
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库]]></title>
        <id>https://blog.cyanzoy.top/post/LfyAN6ymf</id>
        <link href="https://blog.cyanzoy.top/post/LfyAN6ymf">
        </link>
        <updated>2019-09-23T07:59:06.000Z</updated>
        <summary type="html"><![CDATA[<p>一系列命令</p>
]]></summary>
        <content type="html"><![CDATA[<p>一系列命令</p>
<!-- more -->
<h1 id="创建用户授权设更改加密模式">创建用户，授权，设更改加密模式</h1>
<h1 id="创建账号">创建账号</h1>
<pre><code>CREATE USER 'username'@'host' IDENTIFIED BY 'password';
</code></pre>
<h1 id="授权">授权</h1>
<pre><code>GRANT privileges ON databasename.tablename TO 'username'@'host'
GRANT ALL ON databasename.* TO 'username'@'host'
说明:
# privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL 
# databasename：数据库名
# tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用表示，如.*
</code></pre>
<pre><code>注意:
用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:
GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;
</code></pre>
<h1 id="设置与更改用户密码">设置与更改用户密码</h1>
<pre><code>命令:
SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');
如果是当前登陆用户用:
SET PASSWORD = PASSWORD(&quot;newpassword&quot;);
例子:
SET PASSWORD FOR 'pig'@'%' = PASSWORD(&quot;123456&quot;);
</code></pre>
<h1 id="撤销用户权限">撤销用户权限</h1>
<pre><code>REVOKE privilege ON databasename.tablename FROM 'username'@'host';
说明:
privilege, databasename, tablename：同授权部分
例子:
REVOKE SELECT ON *.* FROM 'pig'@'%';
假如你在给用户 'pig'@ '%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON . FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT 操作。
同理，如果授权使用的是GRANT SELECT ON . TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对test数据库中user表的Select权限。
具体信息可以用命令SHOW GRANTS FOR 'pig'@'%'; 查看。
</code></pre>
<h1 id="删除用户">删除用户</h1>
<pre><code>DROP USER 'username'@'host';
</code></pre>
<h1 id="mysql8-加密方式不同如有需要可运行下面这句进行更改">mysql8 加密方式不同，如有需要可运行下面这句进行更改</h1>
<pre><code>ALTER USER 'tone'@'%' IDENTIFIED WITH mysql_native_password BY '123456';
FLUSH PRIVILEGES; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[后端必备 Nginx 配置]]></title>
        <id>https://blog.cyanzoy.top/post/9XwZQILat</id>
        <link href="https://blog.cyanzoy.top/post/9XwZQILat">
        </link>
        <updated>2019-09-19T02:55:54.000Z</updated>
        <summary type="html"><![CDATA[<ul>
<li>防盗链</li>
<li>根据文件类型设置过期时间</li>
<li>静态资源访问</li>
<li>日志配置</li>
<li>日志字段说明</li>
<li>access_log 访问日志</li>
<li>error_log 日志</li>
<li>日志切割</li>
<li>反向代理</li>
<li>禁止指定user_agent</li>
<li>nginx访问控制</li>
<li>负载均衡</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<ul>
<li>防盗链</li>
<li>根据文件类型设置过期时间</li>
<li>静态资源访问</li>
<li>日志配置</li>
<li>日志字段说明</li>
<li>access_log 访问日志</li>
<li>error_log 日志</li>
<li>日志切割</li>
<li>反向代理</li>
<li>禁止指定user_agent</li>
<li>nginx访问控制</li>
<li>负载均衡</li>
</ul>
<!-- more -->
<h2 id="防盗链">防盗链</h2>
<pre><code>location ~* \.(gif|jpg|png)$ {
    # 只允许 192.168.0.1 请求资源
    valid_referers none blocked 192.168.0.1;
    if ($invalid_referer) {
       rewrite ^/ http://$host/logo.png;
    }
}
</code></pre>
<h2 id="根据文件类型设置过期时间">根据文件类型设置过期时间</h2>
<pre><code>location ~.*\.css$ {
    expires 1d;
    break;
}
location ~.*\.js$ {
    expires 1d;
    break;
}
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {
    access_log off;
    expires 15d;    #保存15天
    break;
}

# curl -x127.0.0.1:80 http://www.test.com/static/image/common/logo.png -I #
测试图片的max-age
</code></pre>
<h2 id="静态资源访问">静态资源访问</h2>
<pre><code>http {
    # 这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，
    # 建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。
    open_file_cache max=204800 inactive=20s;

    # open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，
    # 如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个
    # 文件在inactive 时间内一次没被使用，它将被移除。
    open_file_cache_min_uses 1;

    # 这个是指多长时间检查一次缓存的有效信息
    open_file_cache_valid 30s;

    # 默认情况下，Nginx的gzip压缩是关闭的， gzip压缩功能就是可以让你节省不
    # 少带宽，但是会增加服务器CPU的开销哦，Nginx默认只对text/html进行压缩 ，
    # 如果要对html之外的内容进行压缩传输，我们需要手动来设置。
    gzip on;
    gzip_min_length 1k;
    gzip_buffers 4 16k;
    gzip_http_version 1.0;
    gzip_comp_level 2;
    gzip_types text/plain application/x-javascript text/css application/xml;


    server {
        listen       80;
        server_name www.test.com;
        charset utf-8;
        root   /data/www.test.com;
        index  index.html index.htm;
    }
}
</code></pre>
<h2 id="日志配置">日志配置</h2>
<h3 id="日志字段说明">日志字段说明</h3>
<table>
<thead>
<tr>
<th>字段</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>remote_addr 和 http_x_forwarded_for</td>
<td>客户端 IP 地址</td>
</tr>
<tr>
<td>remote_user</td>
<td>客户端用户名称</td>
</tr>
<tr>
<td>request</td>
<td>请求的 URI 和 HTTP 协议</td>
</tr>
<tr>
<td>status</td>
<td>请求状态</td>
</tr>
<tr>
<td>body_bytes_sent</td>
<td>返回给客户端的字节数，不包括响应头的大小</td>
</tr>
<tr>
<td>bytes_sent</td>
<td>返回给客户端总字节数</td>
</tr>
<tr>
<td>connection</td>
<td>连接的序列号</td>
</tr>
<tr>
<td>connection_requests</td>
<td>当前同一个 TCP 连接的的请求数量</td>
</tr>
<tr>
<td>msec</td>
<td>日志写入时间。单位为秒，精度是毫秒</td>
</tr>
<tr>
<td>pipe</td>
<td>如果请求是通过HTTP流水线(pipelined)发送，pipe值为&quot;p&quot;，否则为&quot;.&quot;</td>
</tr>
<tr>
<td>http_referer</td>
<td>记录从哪个页面链接访问过来的</td>
</tr>
<tr>
<td>http_user_agent</td>
<td>记录客户端浏览器相关信息</td>
</tr>
<tr>
<td>request_length</td>
<td>请求的长度(包括请求行，请求头和请求正文)</td>
</tr>
<tr>
<td>time_iso8601</td>
<td>ISO8601标准格式下的本地时间</td>
</tr>
<tr>
<td>time_local</td>
<td>记录访问时间与时区</td>
</tr>
</tbody>
</table>
<h2 id="access_log-访问日志">access_log 访问日志</h2>
<pre><code>http {
    log_format  access  '$remote_addr - $remote_user [$time_local] $host &quot;$request&quot; '
                  '$status $body_bytes_sent &quot;$http_referer&quot; '
                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$clientip&quot;';
    access_log  /srv/log/nginx/talk-fun.access.log  access;
}
</code></pre>
<h2 id="error_log-日志">error_log 日志</h2>
<pre><code>error_log  /srv/log/nginx/nginx_error.log  error;
# error_log /dev/null; # 真正的关闭错误日志
http {
    # ...
}
</code></pre>
<h2 id="日志切割">日志切割</h2>
<pre><code># 和apache不同的是，nginx没有apache一样的工具做切割，需要编写脚本实现。# 在/usr/local/sbin下写脚本

#!/bin/bash
dd=$(date -d '-1 day' +%F)[ -d /tmp/nginx_log ] || mkdir /tmp/nginx_log
mv /tmp/nginx_access.log /tmp/nginx_log/$dd.log
/etc/init.d/nginx reload &gt; /dev/null
</code></pre>
<h2 id="反向代理">反向代理</h2>
<pre><code>http {
    include mime.types;
    server_tokens off;

    ## 配置反向代理的参数
    server {
        listen    8080;

        ## 1. 用户访问 http://ip:port，则反向代理到 https://github.com
        location / {
            proxy_pass  https://github.com;
            proxy_redirect     off;
            proxy_set_header   Host             $host;
            proxy_set_header   X-Real-IP        $remote_addr;
            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
        }

        ## 2.用户访问 http://ip:port/README.md，则反向代理到
        ##   https://github.com/zibinli/blog/blob/master/README.md
        location /README.md {
            proxy_set_header  X-Real-IP  $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass https://github.com/zibinli/blog/blob/master/README.md;
        }
    }
}
</code></pre>
<h2 id="禁止指定user_agent">禁止指定user_agent</h2>
<pre><code>#虚拟主机的配置文件里加入：
if ($http_user_agent ~* 'baidu|360|sohu') #禁止useragent为baidu、360和sohu，~*表示不区分大小写匹配
{
   return 403;
}

location /  和  location  ~ /  优先级是不一样的。 
结合这个文章研究一下吧 http://blog.itpub.net/27181165/viewspace-777202/
curl -A &quot;baidu&quot; -x127.0.0.1:80 www.test.com/forum.php -I    该命令指定百度为user_agent,返回403
</code></pre>
<h2 id="nginx访问控制">nginx访问控制</h2>
<pre><code># 可以设置一些配置禁止一些ip的访问

deny 127.0.0.1;     #全局定义限制，location里的是局部定义的。如果两者冲突，以location这种精确地优先，

location ~ .*admin\.php$ {
    #auth_basic &quot;cct auth&quot;;
    #auth_basic_user_file /usr/local/nginx/conf/.htpasswd;

    allow 127.0.0.1;  只允许127.0.0.1的访问，其他均拒绝
    deny all;

    include fastcgi_params;
    fastcgi_pass unix:/tmp/www.sock;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME /data/www$fastcgi_script_name;
}
</code></pre>
<h2 id="负载均衡">负载均衡</h2>
<pre><code>http {
    upstream test.net {
        ip_hash;
        server 192.168.10.13:80;
        server 192.168.10.14:80  down;
        server 192.168.10.15:8009  max_fails=3  fail_timeout=20s;
        server 192.168.10.16:8080;
    }
    server {
        location / {
            proxy_pass  http://test.net;
        }
    }
}
</code></pre>
<h1 id="nginx的rewrite">Nginx的rewrite</h1>
<h2 id="rewite">rewite</h2>
<p>在<code>server</code>块下，会优先执行<code>rewrite</code>部分，然后才会去匹配<code>location</code>块<br>
<code>server</code>中的<code>rewrite break</code>和<code>last</code>没什么区别，都会去匹配<code>location</code>，所以没必要用<code>last</code>再发起新的请求，可以留空</p>
<h2 id="location中的rewirte">location中的rewirte：</h2>
<p>不写last和break - 那么流程就是依次执行这些rewrite</p>
<ol>
<li><code>rewrite break</code> - url重写后，直接使用当前资源，不再执行location里余下的语句，完成本次请求，地址栏url不变</li>
<li><code>rewrite last</code> - url重写后，马上发起一个新的请求，再次进入server块，重试location匹配，超过10次匹配不到报500错误，地址栏url不变</li>
<li><code>rewrite redirect</code> – 返回302临时重定向，地址栏显示重定向后的url，爬虫不会更新url（因为是临时）</li>
<li><code>rewrite permanent</code> – 返回301永久重定向, 地址栏显示重定向后的url，爬虫更新url</li>
</ol>
<h2 id="使用last会对server标签重新发起请求">使用last会对server标签重新发起请求</h2>
<ul>
<li>如果location中rewrite后是对静态资源的请求，不需要再进行其他匹配，一般要使用break或不写，直接使用当前location中的数据源，完成本次请求</li>
<li>如果location中rewrite后，还需要进行其他处理，如动态fastcgi请求(.php,.jsp)等，要用last继续发起新的请求</li>
<li>(根的location使用last比较好, 因为如果有.php等fastcgi请求还要继续处理)</li>
<li>使用alias指定源：必须使用last</li>
<li>if语句主要用来判断一些在rewrite语句中无法直接匹配的条件,比如检测文件存在与否,http header,cookie等</li>
</ul>
<h2 id="location匹配规则及优先级">location匹配规则及优先级</h2>
<table>
<thead>
<tr>
<th>匹配规则</th>
<th>优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>严格匹配这个查询。如果找到，停止搜索。</td>
</tr>
<tr>
<td>^~</td>
<td>匹配路径的前缀，如果找到，停止搜索。</td>
</tr>
<tr>
<td>~</td>
<td>为区分大小写的正则匹配</td>
</tr>
<tr>
<td>~*</td>
<td>为不区分大小写匹配</td>
</tr>
<tr>
<td>优先级：</td>
<td>=, ^~, <sub>/</sub>*, 无</td>
</tr>
</tbody>
</table>
<h2 id="break语句">break语句</h2>
<p>放在<code>server</code>块<code>rewrite</code>语句前面<br>
如果是直接请求某个真实存在的文件,则用break语句停止rewrite检查</p>
<pre><code>if (-f $request_filename) { 
    break; 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[扣减库存]]></title>
        <id>https://blog.cyanzoy.top/post/UL3LlJVMC</id>
        <link href="https://blog.cyanzoy.top/post/UL3LlJVMC">
        </link>
        <updated>2019-09-18T03:24:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>使用CAS, <code>update table set v_1 = aa where id = xx and v_1 = old_v_1</code></p>
<blockquote>
<p>CAS ☞ compare/check and swap/set</p>
</blockquote>
<p>上面的方案,可能会出现一个CAS中经典问题. ABA的问题.</p>
<pre><code>ABA是指:
线程T1 查询,库存剩余  100
线程T2 查询,库存剩余  100
线程T1 执行subupdate t set surplus = 90 where id = x and surplus = 100;
线程T3 查询, 库存剩余 90
线程T3 执行add  update t set surplus = 100 where id = x and surplus = 90;
线程T2 执行subupdate t set surplus = 90 where id = x and surplus = 100;
</code></pre>
<p>这里线程T2执行的时候,库存的100已经不是查询到的100了<br>
一般的设计中CAS会使用version来控制.</p>
<pre><code>update t set surplus = 90 ,version = version+1 where id = x and version = oldVersion;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git 笔记]]></title>
        <id>https://blog.cyanzoy.top/post/git-bi-ji</id>
        <link href="https://blog.cyanzoy.top/post/git-bi-ji">
        </link>
        <updated>2019-09-17T14:29:28.000Z</updated>
        <summary type="html"><![CDATA[<p>git的一些命令记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>git的一些命令记录</p>
<!-- more -->
<p>🔹Git 添加远程仓库关联</p>
<pre><code>git remote add origin git@github.com:MAOA-L/AliPayApplet.git
git push -u origin master 
#这句一般与上句一起用。用于远程仓库没有初始化时
</code></pre>
<p>🔸Git 本地分支关联远程分支</p>
<pre><code>git branch --set-upstream-to=origin/remote_branch  your_branch
</code></pre>
<p>🔹Git 删除本地分支</p>
<pre><code>git branch -d [branchname]
</code></pre>
<p>🔸Git 删除远程分支</p>
<pre><code>git push origin --delete [branchname]
</code></pre>
<blockquote>
<p><code>Q&amp;A</code><br>
🧐: git branch 不显示分支原因<br>
🤪: git branch要在git commit后才会显示分支.<br>
🧐:nginx的location、root、alias指令用法和区别<br>
🤪:</p>
</blockquote>
]]></content>
    </entry>
</feed>